<!DOCTYPE html>
<html lang="fr-BE">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pong Auto Smiley</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: "Poppins",sans-serif;
            color: #fff;
            background: linear-gradient(120deg, #0f1021, #1b1e4b, #2a0d4a, #103d5d, #0f1021);
            background-size: 300% 300%;
            animation: moveBg 18s ease-in-out infinite;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        @keyframes moveBg {
            0% {
                background-position: 0% 50%
            }

            50% {
                background-position: 100% 50%
            }

            100% {
                background-position: 0% 50%
            }
        }

        canvas {
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,.6);
        }
    </style>
</head>
<body>
    <canvas id="game" width="960" height="540"></canvas>
    <script>(() => {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const field = { w: canvas.width, h: canvas.height, wall: 14 };
            const paddle = (x) => ({ x, y: field.h / 2 - 50, w: 14, h: 100, vy: 0 });
            const p1 = paddle(36), p2 = paddle(field.w - 50);
            const ball = { x: field.w / 2, y: field.h / 2, r: 9, vx: 250, vy: 180 };
            const trail = []; const TRAIL_MAX = 16;

            function serve() {
                ball.x = field.w / 2; ball.y = field.h / 2;
                let angle = (Math.random() * Math.PI / 2 - Math.PI / 4);
                let dir = Math.random() < 0.5 ? -1 : 1;
                let speed = 300;
                ball.vx = Math.cos(angle) * speed * dir;
                ball.vy = Math.sin(angle) * speed;
                trail.length = 0;
            }

            function update(dt) {
                // Auto paddles towards the ball (simple AI)
                const aiSpeed = 260;
                if (ball.y < p1.y + p1.h / 2) p1.y -= aiSpeed * dt;
                if (ball.y > p1.y + p1.h / 2) p1.y += aiSpeed * dt;
                if (ball.y < p2.y + p2.h / 2) p2.y -= aiSpeed * dt;
                if (ball.y > p2.y + p2.h / 2) p2.y += aiSpeed * dt;
                p1.y = Math.max(field.wall, Math.min(field.h - field.wall - p1.h, p1.y));
                p2.y = Math.max(field.wall, Math.min(field.h - field.wall - p2.h, p2.y));

                ball.x += ball.vx * dt; ball.y += ball.vy * dt;

                if (ball.y - ball.r <= field.wall) { ball.y = field.wall + ball.r; ball.vy *= -1; }
                if (ball.y + ball.r >= field.h - field.wall) { ball.y = field.h - field.wall - ball.r; ball.vy *= -1; }

                const hit = (p) => ball.x + ball.r > p.x && ball.x - ball.r < p.x + p.w && ball.y + ball.r > p.y && ball.y - ball.r < p.y + p.h;
                if (ball.vx < 0 && hit(p1)) {
                    ball.x = p1.x + p1.w + ball.r; ball.vx *= -1.05;
                }
                if (ball.vx > 0 && hit(p2)) {
                    ball.x = p2.x - ball.r; ball.vx *= -1.05;
                }

                if (ball.x < -ball.r || ball.x > field.w + ball.r) serve();

                trail.push({ x: ball.x, y: ball.y }); if (trail.length > TRAIL_MAX) trail.shift();
            }

            function roundRect(x, y, w, h, r) {
                const rr = Math.min(r, Math.min(w, h) / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
            }

            function draw() {
                ctx.clearRect(0, 0, field.w, field.h);
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                roundRect(0, 0, field.w, field.wall, 10); ctx.fill();
                roundRect(0, field.h - field.wall, field.w, field.wall, 10); ctx.fill();

                ctx.fillStyle = 'url(#grad)';
                ctx.fillStyle = '#66d2ff';
                roundRect(p1.x, p1.y, p1.w, p1.h, 8); ctx.fill();
                roundRect(p2.x, p2.y, p2.w, p2.h, 8); ctx.fill();

                ctx.save();
                for (let i = 0; i < trail.length; i++) {
                    const t = trail[i]; const alpha = (i + 1) / trail.length * 0.6;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath(); ctx.arc(t.x, t.y, ball.r * (0.8 + i / trail.length * 0.5), 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(128,231,255,0.9)'; ctx.fill();
                }
                ctx.restore();

                ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                ctx.fillStyle = '#fff'; ctx.fill();
            }

            let last = 0;
            function loop(t) {
                let dt = (t - last) / 1000; if (!last) dt = 0; last = t;
                update(dt); draw();
                requestAnimationFrame(loop);
            }

            serve();
            requestAnimationFrame(loop);
        })();</script>
    <script src="randompong.js"></script>
</body>
</html>
















































































<!--/*// Copyrigtht (c) 2025 Citizen Hackathon https://github.com/POLLESSI/Citizenhackathon2025V4.Blazor.Client. All rights reserved.*/-->
<!DOCTYPE html>
<html lang="fr-BE">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pong Auto Smiley</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: "Poppins",sans-serif;
            color: #fff;
            background: linear-gradient(120deg, #0f1021, #1b1e4b, #2a0d4a, #103d5d, #0f1021);
            background-size: 300% 300%;
            animation: moveBg 18s ease-in-out infinite;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        @keyframes moveBg {
            0% {
                background-position: 0% 50%
            }

            50% {
                background-position: 100% 50%
            }

            100% {
                background-position: 0% 50%
            }
        }

        canvas {
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,.6);
        }
    </style>
</head>
<body>
    <canvas id="game" width="960" height="540"></canvas>
    <script>(() => {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const field = { w: canvas.width, h: canvas.height, wall: 14 };
            const paddle = (x) => ({ x, y: field.h / 2 - 50, w: 14, h: 100, vy: 0 });
            const p1 = paddle(36), p2 = paddle(field.w - 50);
            const ball = { x: field.w / 2, y: field.h / 2, r: 9, vx: 250, vy: 180 };
            const trail = []; const TRAIL_MAX = 16;

            function serve() {
                ball.x = field.w / 2; ball.y = field.h / 2;
                let angle = (Math.random() * Math.PI / 2 - Math.PI / 4);
                let dir = Math.random() < 0.5 ? -1 : 1;
                let speed = 300;
                ball.vx = Math.cos(angle) * speed * dir;
                ball.vy = Math.sin(angle) * speed;
                trail.length = 0;
            }

            function update(dt) {
                // Auto paddles towards the ball (simple AI)
                const aiSpeed = 260;
                if (ball.y < p1.y + p1.h / 2) p1.y -= aiSpeed * dt;
                if (ball.y > p1.y + p1.h / 2) p1.y += aiSpeed * dt;
                if (ball.y < p2.y + p2.h / 2) p2.y -= aiSpeed * dt;
                if (ball.y > p2.y + p2.h / 2) p2.y += aiSpeed * dt;
                p1.y = Math.max(field.wall, Math.min(field.h - field.wall - p1.h, p1.y));
                p2.y = Math.max(field.wall, Math.min(field.h - field.wall - p2.h, p2.y));

                ball.x += ball.vx * dt; ball.y += ball.vy * dt;

                if (ball.y - ball.r <= field.wall) { ball.y = field.wall + ball.r; ball.vy *= -1; }
                if (ball.y + ball.r >= field.h - field.wall) { ball.y = field.h - field.wall - ball.r; ball.vy *= -1; }

                const hit = (p) => ball.x + ball.r > p.x && ball.x - ball.r < p.x + p.w && ball.y + ball.r > p.y && ball.y - ball.r < p.y + p.h;
                if (ball.vx < 0 && hit(p1)) {
                    ball.x = p1.x + p1.w + ball.r; ball.vx *= -1.05;
                }
                if (ball.vx > 0 && hit(p2)) {
                    ball.x = p2.x - ball.r; ball.vx *= -1.05;
                }

                if (ball.x < -ball.r || ball.x > field.w + ball.r) serve();

                trail.push({ x: ball.x, y: ball.y }); if (trail.length > TRAIL_MAX) trail.shift();
            }

            function roundRect(x, y, w, h, r) {
                const rr = Math.min(r, Math.min(w, h) / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
            }

            function draw() {
                ctx.clearRect(0, 0, field.w, field.h);
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                roundRect(0, 0, field.w, field.wall, 10); ctx.fill();
                roundRect(0, field.h - field.wall, field.w, field.wall, 10); ctx.fill();

                ctx.fillStyle = 'url(#grad)';
                ctx.fillStyle = '#66d2ff';
                roundRect(p1.x, p1.y, p1.w, p1.h, 8); ctx.fill();
                roundRect(p2.x, p2.y, p2.w, p2.h, 8); ctx.fill();

                ctx.save();
                for (let i = 0; i < trail.length; i++) {
                    const t = trail[i]; const alpha = (i + 1) / trail.length * 0.6;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath(); ctx.arc(t.x, t.y, ball.r * (0.8 + i / trail.length * 0.5), 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(128,231,255,0.9)'; ctx.fill();
                }
                ctx.restore();

                ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                ctx.fillStyle = '#fff'; ctx.fill();
            }

            let last = 0;
            function loop(t) {
                let dt = (t - last) / 1000; if (!last) dt = 0; last = t;
                update(dt); draw();
                requestAnimationFrame(loop);
            }

            serve();
            requestAnimationFrame(loop);
        })();</script>
    <script src="randompong.js"></script>
</body>
</html>
















































































<!--/*// Copyrigtht (c) 2025 Citizen Hackathon https://github.com/POLLESSI/Citizenhackathon2025V5.Blazor.Client. All rights reserved.*/-->